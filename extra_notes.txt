================================= Hook in react ==============================================

https://www.google.com/search?q=react+hook+syntax&oq=react+hook+syntax+&gs_lcrp=EgZjaHJvbWUyBggAEEUYOdIBCDkwMzdqMGo3qAIAsAIA&sourceid=chrome&ie=UTF-8
https://www.w3schools.com/react/react_usestate.asp



React Hooks are functions that let you "hook into" React state and lifecycle features from function components. They allow you to write reusable stateful logic without writing class components.
Here's a look at the syntax for some common React Hooks:
1. useState Hook:
Used for managing local component state.
Code

import React, { useState } from 'react';

function MyComponent() {
  const [stateVariable, setStateVariable] = useState(initialValue); 
  // stateVariable: the current state value
  // setStateVariable: a function to update the state
  // initialValue: the initial value of the state

  // Example:
  const [count, setCount] = useState(0); 

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
2. useEffect Hook:
Used for performing side effects in functional components (e.g., data fetching, DOM manipulation, subscriptions).
Code

import React, { useState, useEffect } from 'react';

function MyComponent() {
  const [data, setData] = useState(null);

  useEffect(() => {
    // This function runs after every render (by default)
    // or when dependencies change.
    // Perform side effects here.
    fetch('https://api.example.com/data')
      .then(response => response.json())
      .then(setData);

    // Optional cleanup function (runs before the component unmounts
    // or before the effect re-runs if dependencies change).
    return () => {
      // Cleanup logic
    };
  }, [/* dependencies array - optional */]); 
  // If empty array [], effect runs only once after initial render.
  // If omitted, effect runs after every render.

  return (
    <div>
      {data ? <p>{data.message}</p> : <p>Loading...</p>}
    </div>
  );
}
3. useContext Hook:
Used for accessing values from a React Context.
Code

import React, { useContext, createContext } from 'react';

const MyContext = createContext('default value');

function MyComponent() {
  const contextValue = useContext(MyContext);

  return <p>Context Value: {contextValue}</p>;
}
4. useRef Hook:
Used for creating mutable ref objects that persist across renders and can be used to access DOM elements or store mutable values.
Code

import React, { useRef } from 'react';

function MyComponent() {
  const inputElement = useRef(null); // initial value is null

  const focusInput = () => {
    inputElement.current.focus();
  };

  return (
    <div>
      <input type="text" ref={inputElement} />
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
}
Custom Hooks:
You can also create your own custom Hooks by defining a function that starts with use and calls other Hooks internally.
Code

function useMyCustomHook(initialValue) {
  const [value, setValue] = useState(initialValue);
  // ... more logic using other Hooks

  return [value, setValue];
}

function AnotherComponent() {
  const [myValue, setMyValue] = useMyCustomHook(10);
  // ...
}




------------------------------------------------------------------------------------------------------------------
5. useReducer Hook:
An alternative to useState for more complex state logic, often when the next state depends on the previous one or involves multiple sub-values.
JavaScript

import React, { useReducer } from 'react';

function reducer(state, action) {
  // ... logic to update state based on action
  return newState;
}

function MyComponent() {
  const [state, dispatch] = useReducer(reducer, initialState, initFunction);
  // ...
}
reducer: A function that takes the current state and an action, and returns the new state.
initialState: The initial state value.
initFunction (optional): A function to lazily initialize the state.
dispatch: A function to dispatch actions to the reducer.
Key Rules of Hooks:
Only call Hooks at the top level: Do not call Hooks inside loops, conditions, or nested functions.
Only call Hooks from React function components or custom Hooks: Do not call them from regular JavaScript functions or class components.



==================================================== props in react ========================================================
https://www.google.com/search?q=props+in+react+js&oq=props+in+react+js&gs_lcrp=EgZjaHJvbWUyBggAEEUYOdIBCTEwMjA2ajBqN6gCCLACAfEF5C6DXcwwTHE&sourceid=chrome&ie=UTF-8
https://www.google.com/search?q=syntax+for+props+in+react+js&oq=syntax+for+props+in+react+js&gs_lcrp=EgZjaHJvbWUyBggAEEUYOTIKCAEQABiABBiiBDIHCAIQABjvBdIBCDgzNDFqMGo3qAIAsAIA&sourceid=chrome&ie=UTF-8


In ReactJS, "props" (short for properties) are a mechanism for passing data from a parent component to a child component. They are a fundamental concept for building reusable and dynamic components in React.
Here's a breakdown of key aspects of props in ReactJS:
One-Way Data Flow: React enforces a unidirectional data flow, meaning data primarily flows down from parent components to child components via props. Child components cannot directly modify the props they receive.
Immutability: Props are considered read-only within the child component. Once a component receives props, it should not attempt to change them. If a component needs to manage data that can change over time, it should use React's state mechanism instead.
Passing Data: You pass props to a child component by adding them as attributes to the component's JSX tag, similar to how you would add attributes to an HTML element.
Code

    // ParentComponent.js
    import ChildComponent from './ChildComponent';

    function ParentComponent() {
      const name = "Alice";
      const age = 30;

      return (
        <ChildComponent userName={name} userAge={age} />
      );
    }
Accessing Props: Inside the child component, you can access the passed props through the props object, which is passed as an argument to functional components or accessed via this.props in class components.
Code

    // ChildComponent.js
    function ChildComponent(props) {
      return (
        <div>
          <p>Name: {props.userName}</p>
          <p>Age: {props.userAge}</p>
        </div>
      );
    }
Making Components Reusable: Props enable you to create generic components that can be customized with different data. For example, a Button component could accept a text prop to display different labels or a color prop to change its appearance.
Callback Functions as Props: You can also pass functions as props from a parent to a child. This allows child components to communicate back to the parent and trigger actions or update the parent's state.
Code

    // ParentComponent.js
    import ChildComponent from './ChildComponent';

    function ParentComponent() {
      const handleClick = () => {
        console.log("Button clicked in child!");
      };

      return (
        <ChildComponent onButtonClick={handleClick} />
      );
    }

    // ChildComponent.js
    function ChildComponent(props) {
      return (
        <button onClick={props.onButtonClick}>Click Me</button>
      );
    }


----------------------------------------------------------------------
In React.js, "props" (short for properties) are a mechanism for passing data from a parent component to a child component. They are read-only and help maintain a unidirectional data flow.
Passing Props (from Parent to Child)
Props are passed to a child component as attributes within its JSX tag, similar to HTML attributes.
Code

// ParentComponent.js
import React from 'react';
import ChildComponent from './ChildComponent';

function ParentComponent() {
  const userName = "Alice";
  const userAge = 30;

  return (
    <div>
      <h1>Parent Component</h1>
      <ChildComponent name={userName} age={userAge} />
    </div>
  );
}

export default ParentComponent;
Accessing Props (in Child Component)
1. Functional Components (using props object):
In a functional component, the props object is received as an argument to the function. Individual props are accessed using dot notation.
Code

// ChildComponent.js
import React from 'react';

function ChildComponent(props) {
  return (
    <div>
      <p>Name: {props.name}</p>
      <p>Age: {props.age}</p>
    </div>
  );
}

export default ChildComponent;
2. Functional Components (using destructuring):
Destructuring the props object within the function signature is a common and cleaner way to access props.
Code

// ChildComponent.js
import React from 'react';

function ChildComponent({ name, age }) { // Destructuring props here
  return (
    <div>
      <p>Name: {name}</p>
      <p>Age: {age}</p>
    </div>
  );
}

export default ChildComponent;
3. Class Components:
In class components, props are accessed via this.props.
Code

// ChildComponent.js
import React, { Component } from 'react';

class ChildComponent extends Component {
  render() {
    return (
      <div>
        <p>Name: {this.props.name}</p>
        <p>Age: {this.props.age}</p>
      </div>
    );
  }
}

export default ChildComponent;
Key Points:
Read-Only: Props cannot be modified by the child component. They are passed down from the parent and remain constant within the child's scope.
Any Data Type: Props can be of any JavaScript data type, including strings, numbers, booleans, objects, arrays, and functions. 
Flow: Props facilitate a one-way data flow from parent to child, promoting predictable state management.    